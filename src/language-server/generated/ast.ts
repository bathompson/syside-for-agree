/******************************************************************************
 * This file was generated by langium-cli 1.1.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import { AstNode, AbstractAstReflection, Reference, ReferenceInfo, TypeMetaData } from 'langium';

export type Annotation = Comment | Documentation | MetadataFeature | TextualRepresentation;

export const Annotation = 'Annotation';

export function isAnnotation(item: unknown): item is Annotation {
    return reflection.isInstance(item, Annotation);
}

export type ClassificationTestOperator = '@' | 'hastype' | 'istype';

export const ClassificationTestOperator = 'ClassificationTestOperator';

export function isClassificationTestOperator(item: unknown): item is ClassificationTestOperator {
    return reflection.isInstance(item, ClassificationTestOperator);
}

export type EqualityOperator = '!=' | '!==' | '==' | '===';

export const EqualityOperator = 'EqualityOperator';

export function isEqualityOperator(item: unknown): item is EqualityOperator {
    return reflection.isInstance(item, EqualityOperator);
}

export type FeatureDirectionKind = 'in' | 'inout' | 'out';

export const FeatureDirectionKind = 'FeatureDirectionKind';

export function isFeatureDirectionKind(item: unknown): item is FeatureDirectionKind {
    return reflection.isInstance(item, FeatureDirectionKind);
}

export type ImportKind = '::*' | '::**' | '::*::**';

export const ImportKind = 'ImportKind';

export function isImportKind(item: unknown): item is ImportKind {
    return reflection.isInstance(item, ImportKind);
}

export type InlineExpression = CollectExpression | FeatureChainExpression | FeatureReferenceExpression | InvocationExpression | LiteralExpression | MetadataAccessExpression | NullExpression | OperatorExpression | SelectExpression | SelfReferenceExpression;

export const InlineExpression = 'InlineExpression';

export function isInlineExpression(item: unknown): item is InlineExpression {
    return reflection.isInstance(item, InlineExpression);
}

export type LiteralExpression = LiteralBoolean | LiteralInfinity | LiteralNumber | LiteralString;

export const LiteralExpression = 'LiteralExpression';

export function isLiteralExpression(item: unknown): item is LiteralExpression {
    return reflection.isInstance(item, LiteralExpression);
}

export type Name = string;

export type ParameterKind = 'actor' | 'stakeholder';

export const ParameterKind = 'ParameterKind';

export function isParameterKind(item: unknown): item is ParameterKind {
    return reflection.isInstance(item, ParameterKind);
}

export type PortionKind = 'snapshot' | 'timeslice';

export const PortionKind = 'PortionKind';

export function isPortionKind(item: unknown): item is PortionKind {
    return reflection.isInstance(item, PortionKind);
}

export type RelationalOperator = '<' | '<=' | '>' | '>=';

export const RelationalOperator = 'RelationalOperator';

export function isRelationalOperator(item: unknown): item is RelationalOperator {
    return reflection.isInstance(item, RelationalOperator);
}

export type RequirementConstraintKind = 'assume' | 'require';

export const RequirementConstraintKind = 'RequirementConstraintKind';

export function isRequirementConstraintKind(item: unknown): item is RequirementConstraintKind {
    return reflection.isInstance(item, RequirementConstraintKind);
}

export type RequirementKind = 'objective' | 'verify';

export const RequirementKind = 'RequirementKind';

export function isRequirementKind(item: unknown): item is RequirementKind {
    return reflection.isInstance(item, RequirementKind);
}

export type StateSubactionKind = 'do' | 'entry' | 'exit';

export const StateSubactionKind = 'StateSubactionKind';

export function isStateSubactionKind(item: unknown): item is StateSubactionKind {
    return reflection.isInstance(item, StateSubactionKind);
}

export type TransitionFeatureKind = 'effect' | 'guard' | 'trigger';

export const TransitionFeatureKind = 'TransitionFeatureKind';

export function isTransitionFeatureKind(item: unknown): item is TransitionFeatureKind {
    return reflection.isInstance(item, TransitionFeatureKind);
}

export type TransparentElement = LoopActionUsage;

export const TransparentElement = 'TransparentElement';

export function isTransparentElement(item: unknown): item is TransparentElement {
    return reflection.isInstance(item, TransparentElement);
}

export type TriggerKind = 'after' | 'at' | 'when';

export const TriggerKind = 'TriggerKind';

export function isTriggerKind(item: unknown): item is TriggerKind {
    return reflection.isInstance(item, TriggerKind);
}

export type TypeOrFeatureReference = FeatureReference | TypeReference;

export const TypeOrFeatureReference = 'TypeOrFeatureReference';

export function isTypeOrFeatureReference(item: unknown): item is TypeOrFeatureReference {
    return reflection.isInstance(item, TypeOrFeatureReference);
}

export type UnaryOperator = '+' | '-' | 'not' | '~';

export const UnaryOperator = 'UnaryOperator';

export function isUnaryOperator(item: unknown): item is UnaryOperator {
    return reflection.isInstance(item, UnaryOperator);
}

export type VisibilityKind = 'private' | 'protected' | 'public';

export const VisibilityKind = 'VisibilityKind';

export function isVisibilityKind(item: unknown): item is VisibilityKind {
    return reflection.isInstance(item, VisibilityKind);
}

export interface Argument extends AstNode {
    readonly $container: InvocationExpression;
    readonly $type: string;
    value: InlineExpression
}

export const Argument = 'Argument';

export function isArgument(item: unknown): item is Argument {
    return reflection.isInstance(item, Argument);
}

export interface ElementReference extends AstNode {
    readonly $container: Alias | Comment | Conjugation | Dependency | Disjoining | Feature | FeatureInverting | Import | InitialNode | InvocationExpression | MetadataAccessExpression | MetadataFeature | NamedArgument | Relationship | SatisfyRequirementUsage | Specialization | TransitionUsage | Type | TypeFeaturing;
    readonly $type: string;
    chain: Array<Reference<Element>>
}

export const ElementReference = 'ElementReference';

export function isElementReference(item: unknown): item is ElementReference {
    return reflection.isInstance(item, ElementReference);
}

export interface FeatureReferenceExpression extends AstNode {
    readonly $container: ActionUsage | Argument | AssignmentActionUsage | ElementFilter | FeatureReferenceExpression | FeatureValue | IfActionUsage | Import | InvocationExpression | LoopActionUsage | Multiplicity | ReferenceUsage | Result | TransitionUsage | TriggerInvocationExpression | WhileLoopActionUsage;
    readonly $type: string;
    expression: InlineExpression
}

export const FeatureReferenceExpression = 'FeatureReferenceExpression';

export function isFeatureReferenceExpression(item: unknown): item is FeatureReferenceExpression {
    return reflection.isInstance(item, FeatureReferenceExpression);
}

export interface FeatureValue extends AstNode {
    readonly $container: Feature;
    readonly $type: string;
    expression: InlineExpression
    isDefault: boolean
    isInitial: boolean
}

export const FeatureValue = 'FeatureValue';

export function isFeatureValue(item: unknown): item is FeatureValue {
    return reflection.isInstance(item, FeatureValue);
}

export interface InvocationExpression extends AstNode {
    readonly $container: ActionUsage | Argument | AssignmentActionUsage | ElementFilter | FeatureReferenceExpression | FeatureValue | IfActionUsage | Import | InvocationExpression | LoopActionUsage | Multiplicity | ReferenceUsage | Result | TransitionUsage | TriggerInvocationExpression | WhileLoopActionUsage;
    readonly $type: string;
    args: Array<Argument> | Array<InlineExpression> | Array<TypeReference>
    type?: TypeReference
}

export const InvocationExpression = 'InvocationExpression';

export function isInvocationExpression(item: unknown): item is InvocationExpression {
    return reflection.isInstance(item, InvocationExpression);
}

export interface LiteralBoolean extends AstNode {
    readonly $container: ActionUsage | Argument | AssignmentActionUsage | ElementFilter | FeatureReferenceExpression | FeatureValue | IfActionUsage | Import | InvocationExpression | LoopActionUsage | Multiplicity | ReferenceUsage | Result | TransitionUsage | TriggerInvocationExpression | WhileLoopActionUsage;
    readonly $type: string;
    value: boolean
}

export const LiteralBoolean = 'LiteralBoolean';

export function isLiteralBoolean(item: unknown): item is LiteralBoolean {
    return reflection.isInstance(item, LiteralBoolean);
}

export interface LiteralInfinity extends AstNode {
    readonly $container: ActionUsage | Argument | AssignmentActionUsage | ElementFilter | FeatureReferenceExpression | FeatureValue | IfActionUsage | Import | InvocationExpression | LoopActionUsage | Multiplicity | ReferenceUsage | Result | TransitionUsage | TriggerInvocationExpression | WhileLoopActionUsage;
    readonly $type: string;
}

export const LiteralInfinity = 'LiteralInfinity';

export function isLiteralInfinity(item: unknown): item is LiteralInfinity {
    return reflection.isInstance(item, LiteralInfinity);
}

export interface LiteralNumber extends AstNode {
    readonly $container: ActionUsage | Argument | AssignmentActionUsage | ElementFilter | FeatureReferenceExpression | FeatureValue | IfActionUsage | Import | InvocationExpression | LoopActionUsage | Multiplicity | ReferenceUsage | Result | TransitionUsage | TriggerInvocationExpression | WhileLoopActionUsage;
    readonly $type: string;
    value: number
}

export const LiteralNumber = 'LiteralNumber';

export function isLiteralNumber(item: unknown): item is LiteralNumber {
    return reflection.isInstance(item, LiteralNumber);
}

export interface LiteralString extends AstNode {
    readonly $container: ActionUsage | Argument | AssignmentActionUsage | ElementFilter | FeatureReferenceExpression | FeatureValue | IfActionUsage | Import | InvocationExpression | LoopActionUsage | Multiplicity | ReferenceUsage | Result | TransitionUsage | TriggerInvocationExpression | WhileLoopActionUsage;
    readonly $type: string;
    value: string
}

export const LiteralString = 'LiteralString';

export function isLiteralString(item: unknown): item is LiteralString {
    return reflection.isInstance(item, LiteralString);
}

export interface MetadataAccessExpression extends AstNode {
    readonly $container: ActionUsage | Argument | AssignmentActionUsage | ElementFilter | FeatureReferenceExpression | FeatureValue | IfActionUsage | Import | InvocationExpression | LoopActionUsage | Multiplicity | ReferenceUsage | Result | TransitionUsage | TriggerInvocationExpression | WhileLoopActionUsage;
    readonly $type: string;
    reference: ElementReference
}

export const MetadataAccessExpression = 'MetadataAccessExpression';

export function isMetadataAccessExpression(item: unknown): item is MetadataAccessExpression {
    return reflection.isInstance(item, MetadataAccessExpression);
}

export interface NullExpression extends AstNode {
    readonly $container: ActionUsage | Argument | AssignmentActionUsage | ElementFilter | FeatureReferenceExpression | FeatureValue | IfActionUsage | Import | InvocationExpression | LoopActionUsage | Multiplicity | ReferenceUsage | Result | TransitionUsage | TriggerInvocationExpression | WhileLoopActionUsage;
    readonly $type: string;
}

export const NullExpression = 'NullExpression';

export function isNullExpression(item: unknown): item is NullExpression {
    return reflection.isInstance(item, NullExpression);
}

export interface SelfReferenceExpression extends AstNode {
    readonly $container: ActionUsage | Argument | AssignmentActionUsage | ElementFilter | FeatureReferenceExpression | FeatureValue | IfActionUsage | Import | InvocationExpression | LoopActionUsage | Multiplicity | ReferenceUsage | Result | TransitionUsage | TriggerInvocationExpression | WhileLoopActionUsage;
    readonly $type: string;
}

export const SelfReferenceExpression = 'SelfReferenceExpression';

export function isSelfReferenceExpression(item: unknown): item is SelfReferenceExpression {
    return reflection.isInstance(item, SelfReferenceExpression);
}

export interface VisibilityElement extends AstNode {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    visibility?: VisibilityKind
}

export const VisibilityElement = 'VisibilityElement';

export function isVisibilityElement(item: unknown): item is VisibilityElement {
    return reflection.isInstance(item, VisibilityElement);
}

export interface NamedArgument extends Argument {
    readonly $container: InvocationExpression;
    readonly $type: string;
    name: FeatureReference
}

export const NamedArgument = 'NamedArgument';

export function isNamedArgument(item: unknown): item is NamedArgument {
    return reflection.isInstance(item, NamedArgument);
}

export interface TypeReference extends ElementReference {
    readonly $container: Alias | Comment | Conjugation | Dependency | Disjoining | Feature | FeatureInverting | Import | InitialNode | InvocationExpression | MetadataAccessExpression | MetadataFeature | NamedArgument | Relationship | SatisfyRequirementUsage | Specialization | TransitionUsage | Type | TypeFeaturing;
    readonly $type: string;
}

export const TypeReference = 'TypeReference';

export function isTypeReference(item: unknown): item is TypeReference {
    return reflection.isInstance(item, TypeReference);
}

export interface OperatorExpression extends InvocationExpression {
    readonly $container: ActionUsage | Argument | AssignmentActionUsage | ElementFilter | FeatureReferenceExpression | FeatureValue | IfActionUsage | Import | InvocationExpression | LoopActionUsage | Multiplicity | ReferenceUsage | Result | TransitionUsage | TriggerInvocationExpression | WhileLoopActionUsage;
    readonly $type: string;
    operator?: string
}

export const OperatorExpression = 'OperatorExpression';

export function isOperatorExpression(item: unknown): item is OperatorExpression {
    return reflection.isInstance(item, OperatorExpression);
}

export interface TriggerInvocationExpression extends InvocationExpression {
    readonly $container: ActionUsage | Argument | AssignmentActionUsage | ElementFilter | FeatureReferenceExpression | FeatureValue | IfActionUsage | Import | InvocationExpression | LoopActionUsage | Multiplicity | ReferenceUsage | Result | TransitionUsage | TriggerInvocationExpression | WhileLoopActionUsage;
    readonly $type: string;
    expression: InlineExpression
    kind: TriggerKind
}

export const TriggerInvocationExpression = 'TriggerInvocationExpression';

export function isTriggerInvocationExpression(item: unknown): item is TriggerInvocationExpression {
    return reflection.isInstance(item, TriggerInvocationExpression);
}

export interface Element extends VisibilityElement {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    aliases: Array<Alias>
    comments: Array<Comment>
    declaredName?: string
    declaredShortName?: string
    docs: Array<Documentation>
    elements: Array<Element>
    features: Array<Feature>
    imports: Array<Import>
    members: Array<Feature>
    metadata: Array<MetadataFeature>
    prefixes: Array<MetadataFeature>
    relationships: Array<Relationship>
    reps: Array<TextualRepresentation>
}

export const Element = 'Element';

export function isElement(item: unknown): item is Element {
    return reflection.isInstance(item, Element);
}

export interface ElementFilter extends VisibilityElement {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    expression: InlineExpression
}

export const ElementFilter = 'ElementFilter';

export function isElementFilter(item: unknown): item is ElementFilter {
    return reflection.isInstance(item, ElementFilter);
}

export interface Result extends VisibilityElement {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    expression: InlineExpression
}

export const Result = 'Result';

export function isResult(item: unknown): item is Result {
    return reflection.isInstance(item, Result);
}

export interface ClassifierReference extends TypeReference {
    readonly $container: Alias | Comment | Conjugation | Dependency | Disjoining | Feature | FeatureInverting | Import | InitialNode | InvocationExpression | MetadataAccessExpression | MetadataFeature | NamedArgument | Relationship | SatisfyRequirementUsage | Specialization | TransitionUsage | Type | TypeFeaturing;
    readonly $type: string;
}

export const ClassifierReference = 'ClassifierReference';

export function isClassifierReference(item: unknown): item is ClassifierReference {
    return reflection.isInstance(item, ClassifierReference);
}

export interface FeatureReference extends TypeReference {
    readonly $container: Alias | Comment | Conjugation | Dependency | Disjoining | Feature | FeatureInverting | Import | InitialNode | InvocationExpression | MetadataAccessExpression | MetadataFeature | NamedArgument | Relationship | SatisfyRequirementUsage | Specialization | TransitionUsage | Type | TypeFeaturing;
    readonly $type: string;
}

export const FeatureReference = 'FeatureReference';

export function isFeatureReference(item: unknown): item is FeatureReference {
    return reflection.isInstance(item, FeatureReference);
}

export interface MetaclassReference extends TypeReference {
    readonly $container: Alias | Comment | Conjugation | Dependency | Disjoining | Feature | FeatureInverting | Import | InitialNode | InvocationExpression | MetadataAccessExpression | MetadataFeature | NamedArgument | Relationship | SatisfyRequirementUsage | Specialization | TransitionUsage | Type | TypeFeaturing;
    readonly $type: string;
}

export const MetaclassReference = 'MetaclassReference';

export function isMetaclassReference(item: unknown): item is MetaclassReference {
    return reflection.isInstance(item, MetaclassReference);
}

export interface CollectExpression extends OperatorExpression {
    readonly $container: ActionUsage | Argument | AssignmentActionUsage | ElementFilter | FeatureReferenceExpression | FeatureValue | IfActionUsage | Import | InvocationExpression | LoopActionUsage | Multiplicity | ReferenceUsage | Result | TransitionUsage | TriggerInvocationExpression | WhileLoopActionUsage;
    readonly $type: string;
}

export const CollectExpression = 'CollectExpression';

export function isCollectExpression(item: unknown): item is CollectExpression {
    return reflection.isInstance(item, CollectExpression);
}

export interface FeatureChainExpression extends OperatorExpression {
    readonly $container: ActionUsage | Argument | AssignmentActionUsage | ElementFilter | FeatureReferenceExpression | FeatureValue | IfActionUsage | Import | InvocationExpression | LoopActionUsage | Multiplicity | ReferenceUsage | Result | TransitionUsage | TriggerInvocationExpression | WhileLoopActionUsage;
    readonly $type: string;
}

export const FeatureChainExpression = 'FeatureChainExpression';

export function isFeatureChainExpression(item: unknown): item is FeatureChainExpression {
    return reflection.isInstance(item, FeatureChainExpression);
}

export interface SelectExpression extends OperatorExpression {
    readonly $container: ActionUsage | Argument | AssignmentActionUsage | ElementFilter | FeatureReferenceExpression | FeatureValue | IfActionUsage | Import | InvocationExpression | LoopActionUsage | Multiplicity | ReferenceUsage | Result | TransitionUsage | TriggerInvocationExpression | WhileLoopActionUsage;
    readonly $type: string;
}

export const SelectExpression = 'SelectExpression';

export function isSelectExpression(item: unknown): item is SelectExpression {
    return reflection.isInstance(item, SelectExpression);
}

export interface Namespace extends Element {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    filters: Array<ElementFilter>
}

export const Namespace = 'Namespace';

export function isNamespace(item: unknown): item is Namespace {
    return reflection.isInstance(item, Namespace);
}

export interface Relationship extends Element {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    source: Array<ElementReference>
    target: Array<ElementReference>
}

export const Relationship = 'Relationship';

export function isRelationship(item: unknown): item is Relationship {
    return reflection.isInstance(item, Relationship);
}

export interface TextualAnnotatingElement extends Element {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    body: string
}

export const TextualAnnotatingElement = 'TextualAnnotatingElement';

export function isTextualAnnotatingElement(item: unknown): item is TextualAnnotatingElement {
    return reflection.isInstance(item, TextualAnnotatingElement);
}

export interface ConjugatedPortReference extends ClassifierReference {
    readonly $container: Alias | Comment | Conjugation | Dependency | Disjoining | Feature | FeatureInverting | Import | InitialNode | InvocationExpression | MetadataAccessExpression | MetadataFeature | NamedArgument | Relationship | SatisfyRequirementUsage | Specialization | TransitionUsage | Type | TypeFeaturing;
    readonly $type: string;
}

export const ConjugatedPortReference = 'ConjugatedPortReference';

export function isConjugatedPortReference(item: unknown): item is ConjugatedPortReference {
    return reflection.isInstance(item, ConjugatedPortReference);
}

export interface Package extends Namespace {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const Package = 'Package';

export function isPackage(item: unknown): item is Package {
    return reflection.isInstance(item, Package);
}

export interface Type extends Namespace {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    conjugates: Array<TypeReference>
    differences: Array<TypeReference>
    disjoins: Array<TypeReference>
    intersects: Array<TypeReference>
    isAbstract?: 'abstract'
    isSufficient: boolean
    multiplicity?: MultiplicityRange
    specializes: Array<TypeReference>
    unions: Array<TypeReference>
}

export const Type = 'Type';

export function isType(item: unknown): item is Type {
    return reflection.isInstance(item, Type);
}

export interface Alias extends Relationship {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    for: ElementReference
}

export const Alias = 'Alias';

export function isAlias(item: unknown): item is Alias {
    return reflection.isInstance(item, Alias);
}

export interface Conjugation extends Relationship {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    general: TypeReference
    specific: TypeReference
}

export const Conjugation = 'Conjugation';

export function isConjugation(item: unknown): item is Conjugation {
    return reflection.isInstance(item, Conjugation);
}

export interface Dependency extends Relationship {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    client: Array<ElementReference>
    supplier: Array<ElementReference>
}

export const Dependency = 'Dependency';

export function isDependency(item: unknown): item is Dependency {
    return reflection.isInstance(item, Dependency);
}

export interface Disjoining extends Relationship {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    disjoined: TypeReference
    disjoining: TypeReference
}

export const Disjoining = 'Disjoining';

export function isDisjoining(item: unknown): item is Disjoining {
    return reflection.isInstance(item, Disjoining);
}

export interface FeatureInverting extends Relationship {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    featureInverted: FeatureReference
    invertingFeature: FeatureReference
}

export const FeatureInverting = 'FeatureInverting';

export function isFeatureInverting(item: unknown): item is FeatureInverting {
    return reflection.isInstance(item, FeatureInverting);
}

export interface Import extends Relationship {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    conditions: Array<InlineExpression>
    importedNamespace?: ElementReference
    importsAll: boolean
    kind?: ImportKind
}

export const Import = 'Import';

export function isImport(item: unknown): item is Import {
    return reflection.isInstance(item, Import);
}

export interface Specialization extends Relationship {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    general: TypeReference
    specific: TypeReference
}

export const Specialization = 'Specialization';

export function isSpecialization(item: unknown): item is Specialization {
    return reflection.isInstance(item, Specialization);
}

export interface TypeFeaturing extends Relationship {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    feature: FeatureReference
    featuringType: TypeReference
}

export const TypeFeaturing = 'TypeFeaturing';

export function isTypeFeaturing(item: unknown): item is TypeFeaturing {
    return reflection.isInstance(item, TypeFeaturing);
}

export interface Comment extends TextualAnnotatingElement {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    about: Array<ElementReference>
}

export const Comment = 'Comment';

export function isComment(item: unknown): item is Comment {
    return reflection.isInstance(item, Comment);
}

export interface TextualRepresentation extends TextualAnnotatingElement {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    language: string
}

export const TextualRepresentation = 'TextualRepresentation';

export function isTextualRepresentation(item: unknown): item is TextualRepresentation {
    return reflection.isInstance(item, TextualRepresentation);
}

export interface LibraryPackage extends Package {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    isStandard: boolean
}

export const LibraryPackage = 'LibraryPackage';

export function isLibraryPackage(item: unknown): item is LibraryPackage {
    return reflection.isInstance(item, LibraryPackage);
}

export interface Classifier extends Type {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const Classifier = 'Classifier';

export function isClassifier(item: unknown): item is Classifier {
    return reflection.isInstance(item, Classifier);
}

export interface Feature extends Type {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    chains: Array<FeatureReference>
    direction?: FeatureDirectionKind
    featuredBy: Array<TypeReference>
    inverseOf: Array<FeatureReference>
    isComposite?: 'composite'
    isDerived?: 'derived'
    isEnd?: 'end'
    isNonunique: boolean
    isOrdered: boolean
    isPortion?: 'portion'
    isReadOnly?: 'readonly'
    redefines: Array<FeatureReference>
    references: Array<FeatureReference>
    subsets: Array<FeatureReference>
    typedBy: Array<TypeReference>
    value?: FeatureValue
}

export const Feature = 'Feature';

export function isFeature(item: unknown): item is Feature {
    return reflection.isInstance(item, Feature);
}

export interface Expose extends Import {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const Expose = 'Expose';

export function isExpose(item: unknown): item is Expose {
    return reflection.isInstance(item, Expose);
}

export interface FeatureTyping extends Specialization {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const FeatureTyping = 'FeatureTyping';

export function isFeatureTyping(item: unknown): item is FeatureTyping {
    return reflection.isInstance(item, FeatureTyping);
}

export interface Subclassification extends Specialization {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const Subclassification = 'Subclassification';

export function isSubclassification(item: unknown): item is Subclassification {
    return reflection.isInstance(item, Subclassification);
}

export interface Subsetting extends Specialization {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const Subsetting = 'Subsetting';

export function isSubsetting(item: unknown): item is Subsetting {
    return reflection.isInstance(item, Subsetting);
}

export interface Subtype extends Specialization {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const Subtype = 'Subtype';

export function isSubtype(item: unknown): item is Subtype {
    return reflection.isInstance(item, Subtype);
}

export interface Documentation extends Comment {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const Documentation = 'Documentation';

export function isDocumentation(item: unknown): item is Documentation {
    return reflection.isInstance(item, Documentation);
}

export interface Association extends Classifier {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const Association = 'Association';

export function isAssociation(item: unknown): item is Association {
    return reflection.isInstance(item, Association);
}

export interface Class extends Classifier {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const Class = 'Class';

export function isClass(item: unknown): item is Class {
    return reflection.isInstance(item, Class);
}

export interface DataType extends Classifier {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const DataType = 'DataType';

export function isDataType(item: unknown): item is DataType {
    return reflection.isInstance(item, DataType);
}

export interface Definition extends Classifier {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    isIndividual: boolean
    isVariation: boolean
    variants: Array<Feature>
}

export const Definition = 'Definition';

export function isDefinition(item: unknown): item is Definition {
    return reflection.isInstance(item, Definition);
}

export interface Connector extends Feature {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    ends: Array<ConnectorEnd>
}

export const Connector = 'Connector';

export function isConnector(item: unknown): item is Connector {
    return reflection.isInstance(item, Connector);
}

export interface ConnectorEnd extends Feature {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const ConnectorEnd = 'ConnectorEnd';

export function isConnectorEnd(item: unknown): item is ConnectorEnd {
    return reflection.isInstance(item, ConnectorEnd);
}

export interface InitialNode extends Feature {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    comments: Array<Comment>
    docs: Array<Documentation>
    element: FeatureReference
    metadata: Array<MetadataUsage>
    reps: Array<TextualRepresentation>
    visibility?: VisibilityKind
}

export const InitialNode = 'InitialNode';

export function isInitialNode(item: unknown): item is InitialNode {
    return reflection.isInstance(item, InitialNode);
}

export interface ItemFeature extends Feature {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const ItemFeature = 'ItemFeature';

export function isItemFeature(item: unknown): item is ItemFeature {
    return reflection.isInstance(item, ItemFeature);
}

export interface MetadataFeature extends Feature {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    about: Array<ElementReference>
}

export const MetadataFeature = 'MetadataFeature';

export function isMetadataFeature(item: unknown): item is MetadataFeature {
    return reflection.isInstance(item, MetadataFeature);
}

export interface Multiplicity extends Feature {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    range?: InlineExpression
}

export const Multiplicity = 'Multiplicity';

export function isMultiplicity(item: unknown): item is Multiplicity {
    return reflection.isInstance(item, Multiplicity);
}

export interface Step extends Feature {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const Step = 'Step';

export function isStep(item: unknown): item is Step {
    return reflection.isInstance(item, Step);
}

export interface Usage extends Feature {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    isIndividual: boolean
    isReference: boolean
    isVariation: boolean
    portionKind?: PortionKind
    variants: Array<Feature>
}

export const Usage = 'Usage';

export function isUsage(item: unknown): item is Usage {
    return reflection.isInstance(item, Usage);
}

export interface Redefinition extends Subsetting {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const Redefinition = 'Redefinition';

export function isRedefinition(item: unknown): item is Redefinition {
    return reflection.isInstance(item, Redefinition);
}

export interface AssociationStructure extends Association, Structure {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const AssociationStructure = 'AssociationStructure';

export function isAssociationStructure(item: unknown): item is AssociationStructure {
    return reflection.isInstance(item, AssociationStructure);
}

export interface Interaction extends Association, Behavior {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const Interaction = 'Interaction';

export function isInteraction(item: unknown): item is Interaction {
    return reflection.isInstance(item, Interaction);
}

export interface Behavior extends Class {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const Behavior = 'Behavior';

export function isBehavior(item: unknown): item is Behavior {
    return reflection.isInstance(item, Behavior);
}

export interface OccurrenceDefinition extends Class, Definition {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const OccurrenceDefinition = 'OccurrenceDefinition';

export function isOccurrenceDefinition(item: unknown): item is OccurrenceDefinition {
    return reflection.isInstance(item, OccurrenceDefinition);
}

export interface Structure extends Class {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const Structure = 'Structure';

export function isStructure(item: unknown): item is Structure {
    return reflection.isInstance(item, Structure);
}

export interface AttributeDefinition extends DataType, Definition {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const AttributeDefinition = 'AttributeDefinition';

export function isAttributeDefinition(item: unknown): item is AttributeDefinition {
    return reflection.isInstance(item, AttributeDefinition);
}

export interface BindingConnector extends Connector {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const BindingConnector = 'BindingConnector';

export function isBindingConnector(item: unknown): item is BindingConnector {
    return reflection.isInstance(item, BindingConnector);
}

export interface ConnectorAsUsage extends Connector, Usage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const ConnectorAsUsage = 'ConnectorAsUsage';

export function isConnectorAsUsage(item: unknown): item is ConnectorAsUsage {
    return reflection.isInstance(item, ConnectorAsUsage);
}

export interface ItemFlow extends Connector, Step {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    of?: ItemFeature
}

export const ItemFlow = 'ItemFlow';

export function isItemFlow(item: unknown): item is ItemFlow {
    return reflection.isInstance(item, ItemFlow);
}

export interface Succession extends Connector {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const Succession = 'Succession';

export function isSuccession(item: unknown): item is Succession {
    return reflection.isInstance(item, Succession);
}

export interface ItemFlowEnd extends ConnectorEnd {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const ItemFlowEnd = 'ItemFlowEnd';

export function isItemFlowEnd(item: unknown): item is ItemFlowEnd {
    return reflection.isInstance(item, ItemFlowEnd);
}

export interface MetadataUsage extends ItemUsage, MetadataFeature {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const MetadataUsage = 'MetadataUsage';

export function isMetadataUsage(item: unknown): item is MetadataUsage {
    return reflection.isInstance(item, MetadataUsage);
}

export interface MultiplicityRange extends Multiplicity {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const MultiplicityRange = 'MultiplicityRange';

export function isMultiplicityRange(item: unknown): item is MultiplicityRange {
    return reflection.isInstance(item, MultiplicityRange);
}

export interface ActionUsage extends OccurrenceUsage, Step {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    actionKind?: StateSubactionKind
    isParallel: boolean
    parameters: Array<ReferenceUsage>
    send?: InlineExpression
    to?: InlineExpression
    via?: InlineExpression
}

export const ActionUsage = 'ActionUsage';

export function isActionUsage(item: unknown): item is ActionUsage {
    return reflection.isInstance(item, ActionUsage);
}

export interface Expression extends Step {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    result?: Result
    return: Array<Feature>
    variants: Array<Feature>
}

export const Expression = 'Expression';

export function isExpression(item: unknown): item is Expression {
    return reflection.isInstance(item, Expression);
}

export interface AttributeUsage extends Usage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const AttributeUsage = 'AttributeUsage';

export function isAttributeUsage(item: unknown): item is AttributeUsage {
    return reflection.isInstance(item, AttributeUsage);
}

export interface OccurrenceUsage extends Usage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const OccurrenceUsage = 'OccurrenceUsage';

export function isOccurrenceUsage(item: unknown): item is OccurrenceUsage {
    return reflection.isInstance(item, OccurrenceUsage);
}

export interface ReferenceUsage extends Usage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    isSubject: boolean
    trigger?: TriggerInvocationExpression
}

export const ReferenceUsage = 'ReferenceUsage';

export function isReferenceUsage(item: unknown): item is ReferenceUsage {
    return reflection.isInstance(item, ReferenceUsage);
}

export interface ConnectionDefinition extends AssociationStructure, PartDefinition {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const ConnectionDefinition = 'ConnectionDefinition';

export function isConnectionDefinition(item: unknown): item is ConnectionDefinition {
    return reflection.isInstance(item, ConnectionDefinition);
}

export interface FlowConnectionDefinition extends ActionDefinition, ConnectionDefinition, Interaction {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const FlowConnectionDefinition = 'FlowConnectionDefinition';

export function isFlowConnectionDefinition(item: unknown): item is FlowConnectionDefinition {
    return reflection.isInstance(item, FlowConnectionDefinition);
}

export interface ActionDefinition extends Behavior, OccurrenceDefinition {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const ActionDefinition = 'ActionDefinition';

export function isActionDefinition(item: unknown): item is ActionDefinition {
    return reflection.isInstance(item, ActionDefinition);
}

export interface SysMLFunction extends Behavior {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    result?: Result
    return: Array<Feature>
}

export const SysMLFunction = 'SysMLFunction';

export function isSysMLFunction(item: unknown): item is SysMLFunction {
    return reflection.isInstance(item, SysMLFunction);
}

export interface ConstraintDefinition extends OccurrenceDefinition, Predicate {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const ConstraintDefinition = 'ConstraintDefinition';

export function isConstraintDefinition(item: unknown): item is ConstraintDefinition {
    return reflection.isInstance(item, ConstraintDefinition);
}

export interface ItemDefinition extends OccurrenceDefinition, Structure {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const ItemDefinition = 'ItemDefinition';

export function isItemDefinition(item: unknown): item is ItemDefinition {
    return reflection.isInstance(item, ItemDefinition);
}

export interface PortDefinition extends OccurrenceDefinition, Structure {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const PortDefinition = 'PortDefinition';

export function isPortDefinition(item: unknown): item is PortDefinition {
    return reflection.isInstance(item, PortDefinition);
}

export interface Metaclass extends Structure {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const Metaclass = 'Metaclass';

export function isMetaclass(item: unknown): item is Metaclass {
    return reflection.isInstance(item, Metaclass);
}

export interface EnumerationDefinition extends AttributeDefinition {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    values: Array<EnumerationUsage>
}

export const EnumerationDefinition = 'EnumerationDefinition';

export function isEnumerationDefinition(item: unknown): item is EnumerationDefinition {
    return reflection.isInstance(item, EnumerationDefinition);
}

export interface BindingConnectorAsUsage extends BindingConnector, ConnectorAsUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const BindingConnectorAsUsage = 'BindingConnectorAsUsage';

export function isBindingConnectorAsUsage(item: unknown): item is BindingConnectorAsUsage {
    return reflection.isInstance(item, BindingConnectorAsUsage);
}

export interface ConnectionUsage extends ConnectorAsUsage, PartUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const ConnectionUsage = 'ConnectionUsage';

export function isConnectionUsage(item: unknown): item is ConnectionUsage {
    return reflection.isInstance(item, ConnectionUsage);
}

export interface SuccessionAsUsage extends ConnectorAsUsage, Succession {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    then: Array<SuccessionAsUsage>
}

export const SuccessionAsUsage = 'SuccessionAsUsage';

export function isSuccessionAsUsage(item: unknown): item is SuccessionAsUsage {
    return reflection.isInstance(item, SuccessionAsUsage);
}

export interface FlowConnectionUsage extends ActionUsage, ConnectionUsage, ItemFlow {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const FlowConnectionUsage = 'FlowConnectionUsage';

export function isFlowConnectionUsage(item: unknown): item is FlowConnectionUsage {
    return reflection.isInstance(item, FlowConnectionUsage);
}

export interface SuccessionItemFlow extends ItemFlow, Succession {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const SuccessionItemFlow = 'SuccessionItemFlow';

export function isSuccessionItemFlow(item: unknown): item is SuccessionItemFlow {
    return reflection.isInstance(item, SuccessionItemFlow);
}

export interface AcceptActionUsage extends ActionUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const AcceptActionUsage = 'AcceptActionUsage';

export function isAcceptActionUsage(item: unknown): item is AcceptActionUsage {
    return reflection.isInstance(item, AcceptActionUsage);
}

export interface AssignmentActionUsage extends ActionUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    left: InlineExpression
    right: InlineExpression
}

export const AssignmentActionUsage = 'AssignmentActionUsage';

export function isAssignmentActionUsage(item: unknown): item is AssignmentActionUsage {
    return reflection.isInstance(item, AssignmentActionUsage);
}

export interface CalculationUsage extends ActionUsage, Expression {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const CalculationUsage = 'CalculationUsage';

export function isCalculationUsage(item: unknown): item is CalculationUsage {
    return reflection.isInstance(item, CalculationUsage);
}

export interface ControlNode extends ActionUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const ControlNode = 'ControlNode';

export function isControlNode(item: unknown): item is ControlNode {
    return reflection.isInstance(item, ControlNode);
}

export interface IfActionUsage extends ActionUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    body: ActionUsage
    condition: InlineExpression
    else?: ActionUsage
}

export const IfActionUsage = 'IfActionUsage';

export function isIfActionUsage(item: unknown): item is IfActionUsage {
    return reflection.isInstance(item, IfActionUsage);
}

export interface LoopActionUsage extends ActionUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    body: ActionUsage
    expression: InlineExpression
}

export const LoopActionUsage = 'LoopActionUsage';

export function isLoopActionUsage(item: unknown): item is LoopActionUsage {
    return reflection.isInstance(item, LoopActionUsage);
}

export interface PerformActionUsage extends ActionUsage, EventOccurrenceUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const PerformActionUsage = 'PerformActionUsage';

export function isPerformActionUsage(item: unknown): item is PerformActionUsage {
    return reflection.isInstance(item, PerformActionUsage);
}

export interface SendActionUsage extends ActionUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const SendActionUsage = 'SendActionUsage';

export function isSendActionUsage(item: unknown): item is SendActionUsage {
    return reflection.isInstance(item, SendActionUsage);
}

export interface StateUsage extends ActionUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    subactions: Array<ActionUsage>
}

export const StateUsage = 'StateUsage';

export function isStateUsage(item: unknown): item is StateUsage {
    return reflection.isInstance(item, StateUsage);
}

export interface TransitionUsage extends ActionUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    effect?: ActionUsage
    else?: SuccessionAsUsage
    guard?: InlineExpression
    source?: FeatureReference
    then?: SuccessionAsUsage
    trigger?: AcceptActionUsage
}

export const TransitionUsage = 'TransitionUsage';

export function isTransitionUsage(item: unknown): item is TransitionUsage {
    return reflection.isInstance(item, TransitionUsage);
}

export interface BooleanExpression extends Expression {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const BooleanExpression = 'BooleanExpression';

export function isBooleanExpression(item: unknown): item is BooleanExpression {
    return reflection.isInstance(item, BooleanExpression);
}

export interface EnumerationUsage extends AttributeUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const EnumerationUsage = 'EnumerationUsage';

export function isEnumerationUsage(item: unknown): item is EnumerationUsage {
    return reflection.isInstance(item, EnumerationUsage);
}

export interface ConstraintUsage extends BooleanExpression, OccurrenceUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    constraintKind?: RequirementConstraintKind
}

export const ConstraintUsage = 'ConstraintUsage';

export function isConstraintUsage(item: unknown): item is ConstraintUsage {
    return reflection.isInstance(item, ConstraintUsage);
}

export interface EventOccurrenceUsage extends OccurrenceUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const EventOccurrenceUsage = 'EventOccurrenceUsage';

export function isEventOccurrenceUsage(item: unknown): item is EventOccurrenceUsage {
    return reflection.isInstance(item, EventOccurrenceUsage);
}

export interface ItemUsage extends OccurrenceUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const ItemUsage = 'ItemUsage';

export function isItemUsage(item: unknown): item is ItemUsage {
    return reflection.isInstance(item, ItemUsage);
}

export interface PortUsage extends OccurrenceUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const PortUsage = 'PortUsage';

export function isPortUsage(item: unknown): item is PortUsage {
    return reflection.isInstance(item, PortUsage);
}

export interface AllocationDefinition extends ConnectionDefinition {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const AllocationDefinition = 'AllocationDefinition';

export function isAllocationDefinition(item: unknown): item is AllocationDefinition {
    return reflection.isInstance(item, AllocationDefinition);
}

export interface InterfaceDefinition extends ConnectionDefinition {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const InterfaceDefinition = 'InterfaceDefinition';

export function isInterfaceDefinition(item: unknown): item is InterfaceDefinition {
    return reflection.isInstance(item, InterfaceDefinition);
}

export interface CalculationDefinition extends ActionDefinition, SysMLFunction {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const CalculationDefinition = 'CalculationDefinition';

export function isCalculationDefinition(item: unknown): item is CalculationDefinition {
    return reflection.isInstance(item, CalculationDefinition);
}

export interface StateDefinition extends ActionDefinition {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    isParallel: boolean
    subactions: Array<ActionUsage>
}

export const StateDefinition = 'StateDefinition';

export function isStateDefinition(item: unknown): item is StateDefinition {
    return reflection.isInstance(item, StateDefinition);
}

export interface Predicate extends SysMLFunction {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const Predicate = 'Predicate';

export function isPredicate(item: unknown): item is Predicate {
    return reflection.isInstance(item, Predicate);
}

export interface RequirementDefinition extends ConstraintDefinition {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const RequirementDefinition = 'RequirementDefinition';

export function isRequirementDefinition(item: unknown): item is RequirementDefinition {
    return reflection.isInstance(item, RequirementDefinition);
}

export interface MetadataDefinition extends ItemDefinition, Metaclass {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const MetadataDefinition = 'MetadataDefinition';

export function isMetadataDefinition(item: unknown): item is MetadataDefinition {
    return reflection.isInstance(item, MetadataDefinition);
}

export interface PartDefinition extends ItemDefinition {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const PartDefinition = 'PartDefinition';

export function isPartDefinition(item: unknown): item is PartDefinition {
    return reflection.isInstance(item, PartDefinition);
}

export interface AllocationUsage extends ConnectionUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const AllocationUsage = 'AllocationUsage';

export function isAllocationUsage(item: unknown): item is AllocationUsage {
    return reflection.isInstance(item, AllocationUsage);
}

export interface InterfaceUsage extends ConnectionUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const InterfaceUsage = 'InterfaceUsage';

export function isInterfaceUsage(item: unknown): item is InterfaceUsage {
    return reflection.isInstance(item, InterfaceUsage);
}

export interface SuccessionFlowConnectionUsage extends FlowConnectionUsage, SuccessionItemFlow {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const SuccessionFlowConnectionUsage = 'SuccessionFlowConnectionUsage';

export function isSuccessionFlowConnectionUsage(item: unknown): item is SuccessionFlowConnectionUsage {
    return reflection.isInstance(item, SuccessionFlowConnectionUsage);
}

export interface CaseUsage extends CalculationUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const CaseUsage = 'CaseUsage';

export function isCaseUsage(item: unknown): item is CaseUsage {
    return reflection.isInstance(item, CaseUsage);
}

export interface DecisionNode extends ControlNode {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const DecisionNode = 'DecisionNode';

export function isDecisionNode(item: unknown): item is DecisionNode {
    return reflection.isInstance(item, DecisionNode);
}

export interface ForkNode extends ControlNode {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const ForkNode = 'ForkNode';

export function isForkNode(item: unknown): item is ForkNode {
    return reflection.isInstance(item, ForkNode);
}

export interface JoinNode extends ControlNode {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const JoinNode = 'JoinNode';

export function isJoinNode(item: unknown): item is JoinNode {
    return reflection.isInstance(item, JoinNode);
}

export interface MergeNode extends ControlNode {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const MergeNode = 'MergeNode';

export function isMergeNode(item: unknown): item is MergeNode {
    return reflection.isInstance(item, MergeNode);
}

export interface ForLoopActionUsage extends LoopActionUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    for: ReferenceUsage
}

export const ForLoopActionUsage = 'ForLoopActionUsage';

export function isForLoopActionUsage(item: unknown): item is ForLoopActionUsage {
    return reflection.isInstance(item, ForLoopActionUsage);
}

export interface WhileLoopActionUsage extends LoopActionUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    until?: InlineExpression
}

export const WhileLoopActionUsage = 'WhileLoopActionUsage';

export function isWhileLoopActionUsage(item: unknown): item is WhileLoopActionUsage {
    return reflection.isInstance(item, WhileLoopActionUsage);
}

export interface ExhibitStateUsage extends PerformActionUsage, StateUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const ExhibitStateUsage = 'ExhibitStateUsage';

export function isExhibitStateUsage(item: unknown): item is ExhibitStateUsage {
    return reflection.isInstance(item, ExhibitStateUsage);
}

export interface IncludeUseCaseUsage extends PerformActionUsage, UseCaseUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const IncludeUseCaseUsage = 'IncludeUseCaseUsage';

export function isIncludeUseCaseUsage(item: unknown): item is IncludeUseCaseUsage {
    return reflection.isInstance(item, IncludeUseCaseUsage);
}

export interface Invariant extends BooleanExpression {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    isNegated: boolean
}

export const Invariant = 'Invariant';

export function isInvariant(item: unknown): item is Invariant {
    return reflection.isInstance(item, Invariant);
}

export interface AssertConstraintUsage extends ConstraintUsage, Invariant {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const AssertConstraintUsage = 'AssertConstraintUsage';

export function isAssertConstraintUsage(item: unknown): item is AssertConstraintUsage {
    return reflection.isInstance(item, AssertConstraintUsage);
}

export interface RequirementUsage extends ConstraintUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    requirementKind?: RequirementKind
}

export const RequirementUsage = 'RequirementUsage';

export function isRequirementUsage(item: unknown): item is RequirementUsage {
    return reflection.isInstance(item, RequirementUsage);
}

export interface PartUsage extends ItemUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    parameterKind?: ParameterKind
}

export const PartUsage = 'PartUsage';

export function isPartUsage(item: unknown): item is PartUsage {
    return reflection.isInstance(item, PartUsage);
}

export interface CaseDefinition extends CalculationDefinition {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const CaseDefinition = 'CaseDefinition';

export function isCaseDefinition(item: unknown): item is CaseDefinition {
    return reflection.isInstance(item, CaseDefinition);
}

export interface ConcernDefinition extends RequirementDefinition {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const ConcernDefinition = 'ConcernDefinition';

export function isConcernDefinition(item: unknown): item is ConcernDefinition {
    return reflection.isInstance(item, ConcernDefinition);
}

export interface ViewpointDefinition extends RequirementDefinition {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const ViewpointDefinition = 'ViewpointDefinition';

export function isViewpointDefinition(item: unknown): item is ViewpointDefinition {
    return reflection.isInstance(item, ViewpointDefinition);
}

export interface RenderingDefinition extends PartDefinition {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const RenderingDefinition = 'RenderingDefinition';

export function isRenderingDefinition(item: unknown): item is RenderingDefinition {
    return reflection.isInstance(item, RenderingDefinition);
}

export interface ViewDefinition extends PartDefinition {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const ViewDefinition = 'ViewDefinition';

export function isViewDefinition(item: unknown): item is ViewDefinition {
    return reflection.isInstance(item, ViewDefinition);
}

export interface AnalysisCaseUsage extends CaseUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const AnalysisCaseUsage = 'AnalysisCaseUsage';

export function isAnalysisCaseUsage(item: unknown): item is AnalysisCaseUsage {
    return reflection.isInstance(item, AnalysisCaseUsage);
}

export interface UseCaseUsage extends CaseUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const UseCaseUsage = 'UseCaseUsage';

export function isUseCaseUsage(item: unknown): item is UseCaseUsage {
    return reflection.isInstance(item, UseCaseUsage);
}

export interface VerificationCaseUsage extends CaseUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const VerificationCaseUsage = 'VerificationCaseUsage';

export function isVerificationCaseUsage(item: unknown): item is VerificationCaseUsage {
    return reflection.isInstance(item, VerificationCaseUsage);
}

export interface SatisfyRequirementUsage extends AssertConstraintUsage, RequirementUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    by?: FeatureReference
}

export const SatisfyRequirementUsage = 'SatisfyRequirementUsage';

export function isSatisfyRequirementUsage(item: unknown): item is SatisfyRequirementUsage {
    return reflection.isInstance(item, SatisfyRequirementUsage);
}

export interface ConcernUsage extends RequirementUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
    isFramed: boolean
}

export const ConcernUsage = 'ConcernUsage';

export function isConcernUsage(item: unknown): item is ConcernUsage {
    return reflection.isInstance(item, ConcernUsage);
}

export interface ViewpointUsage extends RequirementUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const ViewpointUsage = 'ViewpointUsage';

export function isViewpointUsage(item: unknown): item is ViewpointUsage {
    return reflection.isInstance(item, ViewpointUsage);
}

export interface RenderingUsage extends PartUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const RenderingUsage = 'RenderingUsage';

export function isRenderingUsage(item: unknown): item is RenderingUsage {
    return reflection.isInstance(item, RenderingUsage);
}

export interface ViewUsage extends PartUsage {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const ViewUsage = 'ViewUsage';

export function isViewUsage(item: unknown): item is ViewUsage {
    return reflection.isInstance(item, ViewUsage);
}

export interface AnalysisCaseDefinition extends CaseDefinition {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const AnalysisCaseDefinition = 'AnalysisCaseDefinition';

export function isAnalysisCaseDefinition(item: unknown): item is AnalysisCaseDefinition {
    return reflection.isInstance(item, AnalysisCaseDefinition);
}

export interface UseCaseDefinition extends CaseDefinition {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const UseCaseDefinition = 'UseCaseDefinition';

export function isUseCaseDefinition(item: unknown): item is UseCaseDefinition {
    return reflection.isInstance(item, UseCaseDefinition);
}

export interface VerificationCaseDefinition extends CaseDefinition {
    readonly $container: ActionUsage | Connector | Definition | Element | EnumerationDefinition | Expression | ForLoopActionUsage | IfActionUsage | InitialNode | ItemFlow | LoopActionUsage | Namespace | StateDefinition | StateUsage | SuccessionAsUsage | SysMLFunction | TransitionUsage | Type | Usage;
    readonly $type: string;
}

export const VerificationCaseDefinition = 'VerificationCaseDefinition';

export function isVerificationCaseDefinition(item: unknown): item is VerificationCaseDefinition {
    return reflection.isInstance(item, VerificationCaseDefinition);
}

export interface SysMlAstType {
    AcceptActionUsage: AcceptActionUsage
    ActionDefinition: ActionDefinition
    ActionUsage: ActionUsage
    Alias: Alias
    AllocationDefinition: AllocationDefinition
    AllocationUsage: AllocationUsage
    AnalysisCaseDefinition: AnalysisCaseDefinition
    AnalysisCaseUsage: AnalysisCaseUsage
    Annotation: Annotation
    Argument: Argument
    AssertConstraintUsage: AssertConstraintUsage
    AssignmentActionUsage: AssignmentActionUsage
    Association: Association
    AssociationStructure: AssociationStructure
    AttributeDefinition: AttributeDefinition
    AttributeUsage: AttributeUsage
    Behavior: Behavior
    BindingConnector: BindingConnector
    BindingConnectorAsUsage: BindingConnectorAsUsage
    BooleanExpression: BooleanExpression
    CalculationDefinition: CalculationDefinition
    CalculationUsage: CalculationUsage
    CaseDefinition: CaseDefinition
    CaseUsage: CaseUsage
    Class: Class
    ClassificationTestOperator: ClassificationTestOperator
    Classifier: Classifier
    ClassifierReference: ClassifierReference
    CollectExpression: CollectExpression
    Comment: Comment
    ConcernDefinition: ConcernDefinition
    ConcernUsage: ConcernUsage
    ConjugatedPortReference: ConjugatedPortReference
    Conjugation: Conjugation
    ConnectionDefinition: ConnectionDefinition
    ConnectionUsage: ConnectionUsage
    Connector: Connector
    ConnectorAsUsage: ConnectorAsUsage
    ConnectorEnd: ConnectorEnd
    ConstraintDefinition: ConstraintDefinition
    ConstraintUsage: ConstraintUsage
    ControlNode: ControlNode
    DataType: DataType
    DecisionNode: DecisionNode
    Definition: Definition
    Dependency: Dependency
    Disjoining: Disjoining
    Documentation: Documentation
    Element: Element
    ElementFilter: ElementFilter
    ElementReference: ElementReference
    EnumerationDefinition: EnumerationDefinition
    EnumerationUsage: EnumerationUsage
    EqualityOperator: EqualityOperator
    EventOccurrenceUsage: EventOccurrenceUsage
    ExhibitStateUsage: ExhibitStateUsage
    Expose: Expose
    Expression: Expression
    Feature: Feature
    FeatureChainExpression: FeatureChainExpression
    FeatureDirectionKind: FeatureDirectionKind
    FeatureInverting: FeatureInverting
    FeatureReference: FeatureReference
    FeatureReferenceExpression: FeatureReferenceExpression
    FeatureTyping: FeatureTyping
    FeatureValue: FeatureValue
    FlowConnectionDefinition: FlowConnectionDefinition
    FlowConnectionUsage: FlowConnectionUsage
    ForLoopActionUsage: ForLoopActionUsage
    ForkNode: ForkNode
    IfActionUsage: IfActionUsage
    Import: Import
    ImportKind: ImportKind
    IncludeUseCaseUsage: IncludeUseCaseUsage
    InitialNode: InitialNode
    InlineExpression: InlineExpression
    Interaction: Interaction
    InterfaceDefinition: InterfaceDefinition
    InterfaceUsage: InterfaceUsage
    Invariant: Invariant
    InvocationExpression: InvocationExpression
    ItemDefinition: ItemDefinition
    ItemFeature: ItemFeature
    ItemFlow: ItemFlow
    ItemFlowEnd: ItemFlowEnd
    ItemUsage: ItemUsage
    JoinNode: JoinNode
    LibraryPackage: LibraryPackage
    LiteralBoolean: LiteralBoolean
    LiteralExpression: LiteralExpression
    LiteralInfinity: LiteralInfinity
    LiteralNumber: LiteralNumber
    LiteralString: LiteralString
    LoopActionUsage: LoopActionUsage
    MergeNode: MergeNode
    Metaclass: Metaclass
    MetaclassReference: MetaclassReference
    MetadataAccessExpression: MetadataAccessExpression
    MetadataDefinition: MetadataDefinition
    MetadataFeature: MetadataFeature
    MetadataUsage: MetadataUsage
    Multiplicity: Multiplicity
    MultiplicityRange: MultiplicityRange
    NamedArgument: NamedArgument
    Namespace: Namespace
    NullExpression: NullExpression
    OccurrenceDefinition: OccurrenceDefinition
    OccurrenceUsage: OccurrenceUsage
    OperatorExpression: OperatorExpression
    Package: Package
    ParameterKind: ParameterKind
    PartDefinition: PartDefinition
    PartUsage: PartUsage
    PerformActionUsage: PerformActionUsage
    PortDefinition: PortDefinition
    PortUsage: PortUsage
    PortionKind: PortionKind
    Predicate: Predicate
    Redefinition: Redefinition
    ReferenceUsage: ReferenceUsage
    RelationalOperator: RelationalOperator
    Relationship: Relationship
    RenderingDefinition: RenderingDefinition
    RenderingUsage: RenderingUsage
    RequirementConstraintKind: RequirementConstraintKind
    RequirementDefinition: RequirementDefinition
    RequirementKind: RequirementKind
    RequirementUsage: RequirementUsage
    Result: Result
    SatisfyRequirementUsage: SatisfyRequirementUsage
    SelectExpression: SelectExpression
    SelfReferenceExpression: SelfReferenceExpression
    SendActionUsage: SendActionUsage
    Specialization: Specialization
    StateDefinition: StateDefinition
    StateSubactionKind: StateSubactionKind
    StateUsage: StateUsage
    Step: Step
    Structure: Structure
    Subclassification: Subclassification
    Subsetting: Subsetting
    Subtype: Subtype
    Succession: Succession
    SuccessionAsUsage: SuccessionAsUsage
    SuccessionFlowConnectionUsage: SuccessionFlowConnectionUsage
    SuccessionItemFlow: SuccessionItemFlow
    SysMLFunction: SysMLFunction
    TextualAnnotatingElement: TextualAnnotatingElement
    TextualRepresentation: TextualRepresentation
    TransitionFeatureKind: TransitionFeatureKind
    TransitionUsage: TransitionUsage
    TransparentElement: TransparentElement
    TriggerInvocationExpression: TriggerInvocationExpression
    TriggerKind: TriggerKind
    Type: Type
    TypeFeaturing: TypeFeaturing
    TypeOrFeatureReference: TypeOrFeatureReference
    TypeReference: TypeReference
    UnaryOperator: UnaryOperator
    Usage: Usage
    UseCaseDefinition: UseCaseDefinition
    UseCaseUsage: UseCaseUsage
    VerificationCaseDefinition: VerificationCaseDefinition
    VerificationCaseUsage: VerificationCaseUsage
    ViewDefinition: ViewDefinition
    ViewUsage: ViewUsage
    ViewpointDefinition: ViewpointDefinition
    ViewpointUsage: ViewpointUsage
    VisibilityElement: VisibilityElement
    VisibilityKind: VisibilityKind
    WhileLoopActionUsage: WhileLoopActionUsage
}

export class SysMlAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['AcceptActionUsage', 'ActionDefinition', 'ActionUsage', 'Alias', 'AllocationDefinition', 'AllocationUsage', 'AnalysisCaseDefinition', 'AnalysisCaseUsage', 'Annotation', 'Argument', 'AssertConstraintUsage', 'AssignmentActionUsage', 'Association', 'AssociationStructure', 'AttributeDefinition', 'AttributeUsage', 'Behavior', 'BindingConnector', 'BindingConnectorAsUsage', 'BooleanExpression', 'CalculationDefinition', 'CalculationUsage', 'CaseDefinition', 'CaseUsage', 'Class', 'ClassificationTestOperator', 'Classifier', 'ClassifierReference', 'CollectExpression', 'Comment', 'ConcernDefinition', 'ConcernUsage', 'ConjugatedPortReference', 'Conjugation', 'ConnectionDefinition', 'ConnectionUsage', 'Connector', 'ConnectorAsUsage', 'ConnectorEnd', 'ConstraintDefinition', 'ConstraintUsage', 'ControlNode', 'DataType', 'DecisionNode', 'Definition', 'Dependency', 'Disjoining', 'Documentation', 'Element', 'ElementFilter', 'ElementReference', 'EnumerationDefinition', 'EnumerationUsage', 'EqualityOperator', 'EventOccurrenceUsage', 'ExhibitStateUsage', 'Expose', 'Expression', 'Feature', 'FeatureChainExpression', 'FeatureDirectionKind', 'FeatureInverting', 'FeatureReference', 'FeatureReferenceExpression', 'FeatureTyping', 'FeatureValue', 'FlowConnectionDefinition', 'FlowConnectionUsage', 'ForLoopActionUsage', 'ForkNode', 'IfActionUsage', 'Import', 'ImportKind', 'IncludeUseCaseUsage', 'InitialNode', 'InlineExpression', 'Interaction', 'InterfaceDefinition', 'InterfaceUsage', 'Invariant', 'InvocationExpression', 'ItemDefinition', 'ItemFeature', 'ItemFlow', 'ItemFlowEnd', 'ItemUsage', 'JoinNode', 'LibraryPackage', 'LiteralBoolean', 'LiteralExpression', 'LiteralInfinity', 'LiteralNumber', 'LiteralString', 'LoopActionUsage', 'MergeNode', 'Metaclass', 'MetaclassReference', 'MetadataAccessExpression', 'MetadataDefinition', 'MetadataFeature', 'MetadataUsage', 'Multiplicity', 'MultiplicityRange', 'NamedArgument', 'Namespace', 'NullExpression', 'OccurrenceDefinition', 'OccurrenceUsage', 'OperatorExpression', 'Package', 'ParameterKind', 'PartDefinition', 'PartUsage', 'PerformActionUsage', 'PortDefinition', 'PortUsage', 'PortionKind', 'Predicate', 'Redefinition', 'ReferenceUsage', 'RelationalOperator', 'Relationship', 'RenderingDefinition', 'RenderingUsage', 'RequirementConstraintKind', 'RequirementDefinition', 'RequirementKind', 'RequirementUsage', 'Result', 'SatisfyRequirementUsage', 'SelectExpression', 'SelfReferenceExpression', 'SendActionUsage', 'Specialization', 'StateDefinition', 'StateSubactionKind', 'StateUsage', 'Step', 'Structure', 'Subclassification', 'Subsetting', 'Subtype', 'Succession', 'SuccessionAsUsage', 'SuccessionFlowConnectionUsage', 'SuccessionItemFlow', 'SysMLFunction', 'TextualAnnotatingElement', 'TextualRepresentation', 'TransitionFeatureKind', 'TransitionUsage', 'TransparentElement', 'TriggerInvocationExpression', 'TriggerKind', 'Type', 'TypeFeaturing', 'TypeOrFeatureReference', 'TypeReference', 'UnaryOperator', 'Usage', 'UseCaseDefinition', 'UseCaseUsage', 'VerificationCaseDefinition', 'VerificationCaseUsage', 'ViewDefinition', 'ViewUsage', 'ViewpointDefinition', 'ViewpointUsage', 'VisibilityElement', 'VisibilityKind', 'WhileLoopActionUsage'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case AcceptActionUsage:
            case AssignmentActionUsage:
            case ControlNode:
            case IfActionUsage:
            case SendActionUsage:
            case StateUsage:
            case TransitionUsage: {
                return this.isSubtype(ActionUsage, supertype);
            }
            case ActionDefinition: {
                return this.isSubtype(Behavior, supertype) || this.isSubtype(OccurrenceDefinition, supertype);
            }
            case ActionUsage: {
                return this.isSubtype(OccurrenceUsage, supertype) || this.isSubtype(Step, supertype);
            }
            case Alias:
            case Conjugation:
            case Dependency:
            case Disjoining:
            case FeatureInverting:
            case Import:
            case Specialization:
            case TypeFeaturing: {
                return this.isSubtype(Relationship, supertype);
            }
            case AllocationDefinition:
            case InterfaceDefinition: {
                return this.isSubtype(ConnectionDefinition, supertype);
            }
            case AllocationUsage:
            case InterfaceUsage: {
                return this.isSubtype(ConnectionUsage, supertype);
            }
            case AnalysisCaseDefinition:
            case UseCaseDefinition:
            case VerificationCaseDefinition: {
                return this.isSubtype(CaseDefinition, supertype);
            }
            case AnalysisCaseUsage:
            case UseCaseUsage:
            case VerificationCaseUsage: {
                return this.isSubtype(CaseUsage, supertype);
            }
            case AssertConstraintUsage: {
                return this.isSubtype(ConstraintUsage, supertype) || this.isSubtype(Invariant, supertype);
            }
            case Association:
            case Class:
            case DataType:
            case Definition: {
                return this.isSubtype(Classifier, supertype);
            }
            case AssociationStructure: {
                return this.isSubtype(Association, supertype) || this.isSubtype(Structure, supertype);
            }
            case AttributeDefinition: {
                return this.isSubtype(DataType, supertype) || this.isSubtype(Definition, supertype);
            }
            case AttributeUsage:
            case OccurrenceUsage:
            case ReferenceUsage: {
                return this.isSubtype(Usage, supertype);
            }
            case Behavior:
            case Structure: {
                return this.isSubtype(Class, supertype);
            }
            case BindingConnector:
            case Succession: {
                return this.isSubtype(Connector, supertype);
            }
            case BindingConnectorAsUsage: {
                return this.isSubtype(BindingConnector, supertype) || this.isSubtype(ConnectorAsUsage, supertype);
            }
            case BooleanExpression: {
                return this.isSubtype(Expression, supertype);
            }
            case CalculationDefinition: {
                return this.isSubtype(ActionDefinition, supertype) || this.isSubtype(SysMLFunction, supertype);
            }
            case CalculationUsage: {
                return this.isSubtype(ActionUsage, supertype) || this.isSubtype(Expression, supertype);
            }
            case CaseDefinition: {
                return this.isSubtype(CalculationDefinition, supertype);
            }
            case CaseUsage: {
                return this.isSubtype(CalculationUsage, supertype);
            }
            case Classifier:
            case Feature: {
                return this.isSubtype(Type, supertype);
            }
            case ClassifierReference:
            case MetaclassReference: {
                return this.isSubtype(TypeReference, supertype);
            }
            case CollectExpression:
            case FeatureChainExpression:
            case SelectExpression: {
                return this.isSubtype(InlineExpression, supertype) || this.isSubtype(OperatorExpression, supertype);
            }
            case Comment:
            case TextualRepresentation: {
                return this.isSubtype(Annotation, supertype) || this.isSubtype(TextualAnnotatingElement, supertype);
            }
            case ConcernDefinition:
            case ViewpointDefinition: {
                return this.isSubtype(RequirementDefinition, supertype);
            }
            case ConcernUsage:
            case ViewpointUsage: {
                return this.isSubtype(RequirementUsage, supertype);
            }
            case ConjugatedPortReference: {
                return this.isSubtype(ClassifierReference, supertype);
            }
            case ConnectionDefinition: {
                return this.isSubtype(AssociationStructure, supertype) || this.isSubtype(PartDefinition, supertype);
            }
            case ConnectionUsage: {
                return this.isSubtype(ConnectorAsUsage, supertype) || this.isSubtype(PartUsage, supertype);
            }
            case Connector:
            case ConnectorEnd:
            case InitialNode:
            case ItemFeature:
            case Multiplicity:
            case Step:
            case Usage: {
                return this.isSubtype(Feature, supertype);
            }
            case ConnectorAsUsage: {
                return this.isSubtype(Connector, supertype) || this.isSubtype(Usage, supertype);
            }
            case ConstraintDefinition: {
                return this.isSubtype(OccurrenceDefinition, supertype) || this.isSubtype(Predicate, supertype);
            }
            case ConstraintUsage: {
                return this.isSubtype(BooleanExpression, supertype) || this.isSubtype(OccurrenceUsage, supertype);
            }
            case DecisionNode:
            case ForkNode:
            case JoinNode:
            case MergeNode: {
                return this.isSubtype(ControlNode, supertype);
            }
            case Documentation: {
                return this.isSubtype(Annotation, supertype) || this.isSubtype(Comment, supertype);
            }
            case Element:
            case ElementFilter:
            case Result: {
                return this.isSubtype(VisibilityElement, supertype);
            }
            case EnumerationDefinition: {
                return this.isSubtype(AttributeDefinition, supertype);
            }
            case EnumerationUsage: {
                return this.isSubtype(AttributeUsage, supertype);
            }
            case EventOccurrenceUsage:
            case ItemUsage:
            case PortUsage: {
                return this.isSubtype(OccurrenceUsage, supertype);
            }
            case ExhibitStateUsage: {
                return this.isSubtype(PerformActionUsage, supertype) || this.isSubtype(StateUsage, supertype);
            }
            case Expose: {
                return this.isSubtype(Import, supertype);
            }
            case Expression: {
                return this.isSubtype(Step, supertype);
            }
            case FeatureReference: {
                return this.isSubtype(TypeOrFeatureReference, supertype) || this.isSubtype(TypeReference, supertype);
            }
            case FeatureReferenceExpression:
            case InvocationExpression:
            case LiteralExpression:
            case MetadataAccessExpression:
            case NullExpression:
            case SelfReferenceExpression: {
                return this.isSubtype(InlineExpression, supertype);
            }
            case FeatureTyping:
            case Subclassification:
            case Subsetting:
            case Subtype: {
                return this.isSubtype(Specialization, supertype);
            }
            case FlowConnectionDefinition: {
                return this.isSubtype(ActionDefinition, supertype) || this.isSubtype(ConnectionDefinition, supertype) || this.isSubtype(Interaction, supertype);
            }
            case FlowConnectionUsage: {
                return this.isSubtype(ActionUsage, supertype) || this.isSubtype(ConnectionUsage, supertype) || this.isSubtype(ItemFlow, supertype);
            }
            case ForLoopActionUsage:
            case WhileLoopActionUsage: {
                return this.isSubtype(LoopActionUsage, supertype);
            }
            case IncludeUseCaseUsage: {
                return this.isSubtype(PerformActionUsage, supertype) || this.isSubtype(UseCaseUsage, supertype);
            }
            case Interaction: {
                return this.isSubtype(Association, supertype) || this.isSubtype(Behavior, supertype);
            }
            case Invariant: {
                return this.isSubtype(BooleanExpression, supertype);
            }
            case ItemDefinition:
            case PortDefinition: {
                return this.isSubtype(OccurrenceDefinition, supertype) || this.isSubtype(Structure, supertype);
            }
            case ItemFlow: {
                return this.isSubtype(Connector, supertype) || this.isSubtype(Step, supertype);
            }
            case ItemFlowEnd: {
                return this.isSubtype(ConnectorEnd, supertype);
            }
            case LibraryPackage: {
                return this.isSubtype(Package, supertype);
            }
            case LiteralBoolean:
            case LiteralInfinity:
            case LiteralNumber:
            case LiteralString: {
                return this.isSubtype(LiteralExpression, supertype);
            }
            case LoopActionUsage: {
                return this.isSubtype(ActionUsage, supertype) || this.isSubtype(TransparentElement, supertype);
            }
            case Metaclass: {
                return this.isSubtype(Structure, supertype);
            }
            case MetadataDefinition: {
                return this.isSubtype(ItemDefinition, supertype) || this.isSubtype(Metaclass, supertype);
            }
            case MetadataFeature: {
                return this.isSubtype(Annotation, supertype) || this.isSubtype(Feature, supertype);
            }
            case MetadataUsage: {
                return this.isSubtype(ItemUsage, supertype) || this.isSubtype(MetadataFeature, supertype);
            }
            case MultiplicityRange: {
                return this.isSubtype(Multiplicity, supertype);
            }
            case NamedArgument: {
                return this.isSubtype(Argument, supertype);
            }
            case Namespace:
            case Relationship:
            case TextualAnnotatingElement: {
                return this.isSubtype(Element, supertype);
            }
            case OccurrenceDefinition: {
                return this.isSubtype(Class, supertype) || this.isSubtype(Definition, supertype);
            }
            case OperatorExpression: {
                return this.isSubtype(InlineExpression, supertype) || this.isSubtype(InvocationExpression, supertype);
            }
            case Package:
            case Type: {
                return this.isSubtype(Namespace, supertype);
            }
            case PartDefinition: {
                return this.isSubtype(ItemDefinition, supertype);
            }
            case PartUsage: {
                return this.isSubtype(ItemUsage, supertype);
            }
            case PerformActionUsage: {
                return this.isSubtype(ActionUsage, supertype) || this.isSubtype(EventOccurrenceUsage, supertype);
            }
            case Predicate: {
                return this.isSubtype(SysMLFunction, supertype);
            }
            case Redefinition: {
                return this.isSubtype(Subsetting, supertype);
            }
            case RenderingDefinition:
            case ViewDefinition: {
                return this.isSubtype(PartDefinition, supertype);
            }
            case RenderingUsage:
            case ViewUsage: {
                return this.isSubtype(PartUsage, supertype);
            }
            case RequirementDefinition: {
                return this.isSubtype(ConstraintDefinition, supertype);
            }
            case RequirementUsage: {
                return this.isSubtype(ConstraintUsage, supertype);
            }
            case SatisfyRequirementUsage: {
                return this.isSubtype(AssertConstraintUsage, supertype) || this.isSubtype(RequirementUsage, supertype);
            }
            case StateDefinition: {
                return this.isSubtype(ActionDefinition, supertype);
            }
            case SuccessionAsUsage: {
                return this.isSubtype(ConnectorAsUsage, supertype) || this.isSubtype(Succession, supertype);
            }
            case SuccessionFlowConnectionUsage: {
                return this.isSubtype(FlowConnectionUsage, supertype) || this.isSubtype(SuccessionItemFlow, supertype);
            }
            case SuccessionItemFlow: {
                return this.isSubtype(ItemFlow, supertype) || this.isSubtype(Succession, supertype);
            }
            case SysMLFunction: {
                return this.isSubtype(Behavior, supertype);
            }
            case TriggerInvocationExpression: {
                return this.isSubtype(InvocationExpression, supertype);
            }
            case TypeReference: {
                return this.isSubtype(ElementReference, supertype) || this.isSubtype(TypeOrFeatureReference, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'ClassifierReference:chain':
            case 'ConjugatedPortReference:chain':
            case 'ElementReference:chain':
            case 'FeatureReference:chain':
            case 'MetaclassReference:chain':
            case 'TypeReference:chain': {
                return Element;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'ElementReference': {
                return {
                    name: 'ElementReference',
                    mandatory: [
                        { name: 'chain', type: 'array' }
                    ]
                };
            }
            case 'FeatureValue': {
                return {
                    name: 'FeatureValue',
                    mandatory: [
                        { name: 'isDefault', type: 'boolean' },
                        { name: 'isInitial', type: 'boolean' }
                    ]
                };
            }
            case 'InvocationExpression': {
                return {
                    name: 'InvocationExpression',
                    mandatory: [
                        { name: 'args', type: 'array' }
                    ]
                };
            }
            case 'LiteralBoolean': {
                return {
                    name: 'LiteralBoolean',
                    mandatory: [
                        { name: 'value', type: 'boolean' }
                    ]
                };
            }
            case 'Element': {
                return {
                    name: 'Element',
                    mandatory: [
                        { name: 'aliases', type: 'array' },
                        { name: 'comments', type: 'array' },
                        { name: 'docs', type: 'array' },
                        { name: 'elements', type: 'array' },
                        { name: 'features', type: 'array' },
                        { name: 'imports', type: 'array' },
                        { name: 'members', type: 'array' },
                        { name: 'metadata', type: 'array' },
                        { name: 'prefixes', type: 'array' },
                        { name: 'relationships', type: 'array' },
                        { name: 'reps', type: 'array' }
                    ]
                };
            }
            case 'Namespace': {
                return {
                    name: 'Namespace',
                    mandatory: [
                        { name: 'filters', type: 'array' }
                    ]
                };
            }
            case 'Relationship': {
                return {
                    name: 'Relationship',
                    mandatory: [
                        { name: 'source', type: 'array' },
                        { name: 'target', type: 'array' }
                    ]
                };
            }
            case 'Type': {
                return {
                    name: 'Type',
                    mandatory: [
                        { name: 'conjugates', type: 'array' },
                        { name: 'differences', type: 'array' },
                        { name: 'disjoins', type: 'array' },
                        { name: 'intersects', type: 'array' },
                        { name: 'isSufficient', type: 'boolean' },
                        { name: 'specializes', type: 'array' },
                        { name: 'unions', type: 'array' }
                    ]
                };
            }
            case 'Dependency': {
                return {
                    name: 'Dependency',
                    mandatory: [
                        { name: 'client', type: 'array' },
                        { name: 'supplier', type: 'array' }
                    ]
                };
            }
            case 'Import': {
                return {
                    name: 'Import',
                    mandatory: [
                        { name: 'conditions', type: 'array' },
                        { name: 'importsAll', type: 'boolean' }
                    ]
                };
            }
            case 'Comment': {
                return {
                    name: 'Comment',
                    mandatory: [
                        { name: 'about', type: 'array' }
                    ]
                };
            }
            case 'LibraryPackage': {
                return {
                    name: 'LibraryPackage',
                    mandatory: [
                        { name: 'isStandard', type: 'boolean' }
                    ]
                };
            }
            case 'Feature': {
                return {
                    name: 'Feature',
                    mandatory: [
                        { name: 'chains', type: 'array' },
                        { name: 'featuredBy', type: 'array' },
                        { name: 'inverseOf', type: 'array' },
                        { name: 'isNonunique', type: 'boolean' },
                        { name: 'isOrdered', type: 'boolean' },
                        { name: 'redefines', type: 'array' },
                        { name: 'references', type: 'array' },
                        { name: 'subsets', type: 'array' },
                        { name: 'typedBy', type: 'array' }
                    ]
                };
            }
            case 'Definition': {
                return {
                    name: 'Definition',
                    mandatory: [
                        { name: 'isIndividual', type: 'boolean' },
                        { name: 'isVariation', type: 'boolean' },
                        { name: 'variants', type: 'array' }
                    ]
                };
            }
            case 'Connector': {
                return {
                    name: 'Connector',
                    mandatory: [
                        { name: 'ends', type: 'array' }
                    ]
                };
            }
            case 'InitialNode': {
                return {
                    name: 'InitialNode',
                    mandatory: [
                        { name: 'comments', type: 'array' },
                        { name: 'docs', type: 'array' },
                        { name: 'metadata', type: 'array' },
                        { name: 'reps', type: 'array' }
                    ]
                };
            }
            case 'MetadataFeature': {
                return {
                    name: 'MetadataFeature',
                    mandatory: [
                        { name: 'about', type: 'array' }
                    ]
                };
            }
            case 'Usage': {
                return {
                    name: 'Usage',
                    mandatory: [
                        { name: 'isIndividual', type: 'boolean' },
                        { name: 'isReference', type: 'boolean' },
                        { name: 'isVariation', type: 'boolean' },
                        { name: 'variants', type: 'array' }
                    ]
                };
            }
            case 'ActionUsage': {
                return {
                    name: 'ActionUsage',
                    mandatory: [
                        { name: 'isParallel', type: 'boolean' },
                        { name: 'parameters', type: 'array' }
                    ]
                };
            }
            case 'Expression': {
                return {
                    name: 'Expression',
                    mandatory: [
                        { name: 'return', type: 'array' },
                        { name: 'variants', type: 'array' }
                    ]
                };
            }
            case 'ReferenceUsage': {
                return {
                    name: 'ReferenceUsage',
                    mandatory: [
                        { name: 'isSubject', type: 'boolean' }
                    ]
                };
            }
            case 'SysMLFunction': {
                return {
                    name: 'SysMLFunction',
                    mandatory: [
                        { name: 'return', type: 'array' }
                    ]
                };
            }
            case 'EnumerationDefinition': {
                return {
                    name: 'EnumerationDefinition',
                    mandatory: [
                        { name: 'values', type: 'array' }
                    ]
                };
            }
            case 'SuccessionAsUsage': {
                return {
                    name: 'SuccessionAsUsage',
                    mandatory: [
                        { name: 'then', type: 'array' }
                    ]
                };
            }
            case 'StateUsage': {
                return {
                    name: 'StateUsage',
                    mandatory: [
                        { name: 'subactions', type: 'array' }
                    ]
                };
            }
            case 'StateDefinition': {
                return {
                    name: 'StateDefinition',
                    mandatory: [
                        { name: 'isParallel', type: 'boolean' },
                        { name: 'subactions', type: 'array' }
                    ]
                };
            }
            case 'Invariant': {
                return {
                    name: 'Invariant',
                    mandatory: [
                        { name: 'isNegated', type: 'boolean' }
                    ]
                };
            }
            case 'ConcernUsage': {
                return {
                    name: 'ConcernUsage',
                    mandatory: [
                        { name: 'isFramed', type: 'boolean' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new SysMlAstReflection();
